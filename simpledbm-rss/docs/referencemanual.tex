\documentclass[oneside]{book}
\title{SimpleDBM Developer's Reference Manual}
\author{Dibyendu Majumdar\\
dibyendu@mazumdar.demon.co.uk\\
Copyright \copyright 2005, 2006}
\date{Revised \today}
\begin{document}
\maketitle
%\setlength{\parindent}{0pt}
%\setlength{\parskip}{\baselineskip}
\tableofcontents
\chapter{Introduction}
\section{Overview}
The goal of SimpleDBM project is to build a Relational Database
Manager in Java. It is primarily an educational project. The aim is
to implement a number of key features of a Relational Database, such
as:
\begin{enumerate}
    \item Transactions
    \item Write Ahead Log
    \item Multiple Isolation Levels
    \item B-Tree Indexes
    \item Entry Level SQL-92
    \item System Catalogs
\end{enumerate}

A primary design goal of SimpleDBM is to build the DBMS in a modular
fashion where each Module can be used on its own. In practice, this
is difficult because there are bound to be dependencies amongst
Modules. A conscious effort is being made to to restrict the
dependencies to a small set of well specified interfaces.

It is anticipated that there will be two major sub-systems in the
dbms backend. The Data Manager subsystem (Relational Storage System
or RSS in System R parlance) will be responsible for implementing
low-level stuff such as transactions, locking, buffer management,
table and index management.

The second major sub-system will be called SQL Manager (Relational
Data System or RDS). Its job will be to parse SQL statements,
produce optimum execution plans, and execute SQL statements.

At present, development of the RSS component is ongoing. The
remainder of this document describes the RSS components that are
currently available.

\section{Technology}
SimpleDBM is being built in Java 5.0 and will use new features such
as \verb|java.util.concurrent| package and Generics. SimpleDBM will
not be compatible with previous versions of Java.

\section{Building SimpleDBM}

\subsection{Download required software}
\subsubsection{J2SE 5.0 SDK or above}
SimpleDBM requires J2SE 5.0 or above. Download JDK from
	\verb|http://java.sun.com/j2se| and install it on your machine.
	
\subsubsection{Maven}
Download Maven 2 from \verb|http://maven.apache.org/| and install it.

\subsubsection{Eclipse}
Download a binary distribution of Eclipse 3.2 from \verb|http://www.eclipse.org|.

Make sure that Eclipse is setup to use J2SE 5.0 JRE, otherwise,
SimpleDBM code will not compile. 

\subsection{Configure Eclipse}
Create a new classpath variable named \verb|M2_REPO| inside
Eclipse. From the menu bar, select Window \verb|>| Preferences. Select the Java
\verb|>| Build Path \verb|>| Classpath Variables page.

This variable should contain the path to your local Maven 2
repository. Usually this is under \verb|<Your Home Directory>/.m2/repository|.

\subsection{Checkout SimpleDBM code}
\begin{enumerate}
\item Create a new SVN repository location in Eclipse \linebreak
 \verb|http://simpledbm.googlecode.com/svn/trunk/simpledbm-rss/code|.
 If you are a committer, use https instead of http.
\item Checkout the folder simpledbm-rss as a project in the
	workspace.
\item Start a command shell. Cd to the project directory.
\item Run \verb|mvn eclipse:clean|, followed by \verb|mvn	eclipse:eclipse|.
\item Switch back to Eclipse and refresh the project. It should now
	have a J against the project showing that it is a Java project. Eclipse
	is now setup to automatically rebuild SimpleDBM whenever you change any
	code.
\item You can also build the SimpleDBM package using the Maven
	command line. From the project home directory, execute \verb|mvn package|.
\end{enumerate}

\subsection{Test Code Coverage}
I use Clover Code Coverage tool to analyse the coverage of unit test cases.

\subsubsection{Installing Clover plug-in in Eclipse}
The Clover plugin for Eclipse can be downloaded from the Clover
	website \verb|http://www.cenqua.com/clover/|. After
downloading, extract the zip file and place contents in your Eclipse
plugins folder. You will need to separately download and install a
license file in the top-level Clover plugin directory. Restart Eclipse
to enable Clover.

Open the Project Properties window, and navigate to the Clover
tab. Click Enable Clover plugin in this project. Click on the
Compilation tab. Enable Fork compiler into separate JVM. Enter the Java
5.0 JDK installation directory in the \verb|JDK_HOME| field, and set the Heap
size of the compiler JVM to 64 MB.

In the Clover View, select SimpleDBM project, and click on the
button Toggle Compiling with Clover. Now when you build SimpleDBM or run
any of the unit tests, Clover will automatically produce coverage data.

\subsubsection{Clover support in Maven builds}
The SimpleDBM Maven build script is already configured for
Clover. You must save the Clover license file to
\verb|src/test/clover/clover.license| prior to executing mvn.

To build SimpleDBM with Clover enabled, and to produce a coverage
report, run:
\begin{verbatim}
mvn clover:instrument clover:clover
\end{verbatim}

The report will be produced in the folder \verb|target/site/clover|.

\chapter{Coding and Design Principles}
\section{Modular design}
SimpleDBM is broken down into modules. Each module implements a
particular sub-system, and is contained in its own package.

Each module has a public API, which is specified via a set of Java
interfaces. Classes must not be used as part of the public API,
though there are a few exceptional cases.

To make the modules reusable and as independent of each other as
possible, the interface of a module is deliberately specified in
general terms. Where possible, direct dependence between modules is
avoided. If two modules are dependent, then the only permissible way
for one module to interact with another is to go via the public
interfaces of the respective modules. Modules are not allowed to
depend upon implementation specifics of other modules.

SimpleDBM uses constructor based dependency injection to link
modules. It is being designed in such a way that a third-party IoC
(Inversion of Control) container may be used to manage the
dependencies.

\section{Documentation}
Most of the design documentation for SimpleDBM is incorporated as
Javadoc comments within the source code, and in package and overview
documents. The aim is to keep the documentation as close to the
source code as possible.

Being an educational project, producing good documentation is high
priority.

\section{Java coding standards}
Heavy use is made of the new concurrency packages in Java 5.0. Enums
are used where appropriate. SimpleDBM does not define any Generic
classes itself, but makes liberal use of Java 5.0 Generic classes.

Fine grained thread locking is used to maximize concurrency. Using
coarse grained locking would have simplified the code, but would not
have provided an opportunity for exploring various techniques for
fine-grained locking. Deadlock is avoided by careful ordering of
locks.

Memory management is left to the Garbage Collector. Rather than
using Object pools, SimpleDBM encourages the use of short-lived
objects, on the basis that this aids the garbage collector in
reclaiming space more quickly. The aim is to keep permanently
occupied memory to a low level.

Checked Exceptions are used in most cases. Each module defines its
own Exception hierarchy. Exceptions are either handled or passed up
the stack - if they are ignored then this is documented in the code.
Care is taken to report Exceptions properly. All error messages are
given error codes.

Particular attention is paid to cleaning up of resources. To ensure
that resources are cleaned up during normal as well as exceptional
circumstances, finally blocks are used.

Debug messages are used liberally - and are executed conditionally
so that if debug is switched off, there is minimal impact on
performance.

\section{Third party libraries}
To void license compatibility issues, and to reduce dependency on
third-party libraries, SimpleDBM makes little or no use of any
external libraries. A custom wrapper is used for logging, which uses
the Java logging API underneath. That said, SimpleDBM is designed in
such a way that it can make good use of IoC containers.

\section{Test Cases}
Each module is accompanied with JUnit test cases.

\section{Release schedule}
The system is designed so that each module is usable once it is
delivered. This means that although the full system has not yet been
constructed, the individual modules can be used as soon as they are
available.

\chapter{Data Manager/RSS Components}
The Data Manager/Relational Storage system consists of the
components listed in the table given below.

\begin{table}[ht]
\begin{tabular}{|l|p{6cm}|}
\hline \textbf{Package}&
\textbf{Description} \\
\hline \verb|org.simpledbm.rss.api.registry|&
The Object Registry subsystem is responsible for constructing objects based upon type information.  \\
\hline \verb|org.simpledbm.rss.api.st|&
The Storage Manager subsystem provides an abstraction layer for disk input/output.  \\
\hline \verb|org.simpledbm.rss.api.latch|&
Latches are efficient locks used to manage mutual exclusion between threads.  \\
\hline \verb|org.simpledbm.rss.api.wal|&
The Write Ahead Log is used to record changes being made to the database for recovery purposes. \\
\hline \verb|org.simpledbm.rss.api.locking|&
The Lock Manager subsystem provides facilities for managing table and row level locks. \\
\hline \verb|org.simpledbm.rss.pm|&
The Page Manager subsystem defines the Page size and manages mapping of pages to the storage subsystem. \\
\hline \verb|org.simpledbm.rss.bm|&
The Buffer Manager implements the Page Buffer Cache, where recently accessed disk pages are stored temporarily. \\
\hline \verb|org.simpledbm.rss.tm|&
The Transaction Manager subsystem manages transactions, system restart and recovery. \\
\hline \verb|org.simpledbm.rss.sm|&
The Space Manager subsystem is responsible for managing free space information within storage containers. \\
\hline \verb|org.simpledbm.rss.sp|&
The Slotted Page Manager module provides a common implementation of a Page structure containing slot table. \\
\hline \verb|org.simpledbm.rss.bt|&
The Index Manager implements B-Tree indexes. The default implementation is a B-link tree. \\
\hline \verb|org.simpledbm.rss.tuple|&
Tuple Manager module is responsible for handling tuples, which are like table rows, and can span multiple pages. Tuples are low-level entities which can be the basis for implementing table rows. \\
\hline
\end{tabular}
\label{tab1} \caption{RSS Modules}
\end{table}

\chapter{Object Registry}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.api.registry| & \verb|org.simpledbm.common.registry.impl| \\
\hline
\end{tabular}


\section{Overview}
In any object oriented persistence system, there has to be a
mechanism for creating objects dynamically, given some form of type
identification. SimpleDBM uses a simple Object Registry database for
this purpose. Each class that may be dynamically instantiated is
assigned a unique type code. The type code and the associated class
name is registered in the SimpleDBM Object Registry. The typecode
can subsequently be used to request an object of the specified
class.

\section{Registering a class}
Before an object of a particular type can be instantiated, its class
must be registered with the Object Registry. An example of how this
is done is shown below:

\begin{verbatim}
ObjectFactory objectFactory = new ObjectFactoryImpl();
objectFactory.register(1, String.class.getName());
\end{verbatim}

Above registers the \verb|String| class with the Object Registry. It
assigns the type code 1 to the \verb|String| class. Objects of the
registered classes may be instantiated using their type codes:

\begin{verbatim}
String t = (String) objectFactory.getInstance(1);
\end{verbatim}

For a class to be eligible for registration, it must implement the
default no-argument constructor.

\section{Registering Singletons}
SimpleDBM's object registry also supports registration of
singletons. Instead of the class name, simply supply an Object
instance. Example:

\begin{verbatim}
ObjectFactory objectFactory = new ObjectFactoryImpl();
objectFactory.register(1, new String(``hello''));
\end{verbatim}

\section{Object Registry aware classes}
Some objects may need to obtain instances of other classes. To do
this, objects of such classes need access to the Object Registry. If
a class implements the \verb|ObjectFactoryAware| interface, then it
will be injected with the appropriate Object Registry object at the
time of initialisation.

Example:

\begin{verbatim}
class MyObject implements ObjectFactoryAware {
    ObjectFactory objectFactory;
    public void setObjectFactory(ObjectFactory factory) {
        this.objectFactory = factory;
    }
    public MyObject() {
    }
}
\end{verbatim}

\chapter{Storage Manager}

\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.api.st| & \verb|org.simpledbm.rss.io.impl| \\
\hline
\end{tabular}

\section{Overview}
Database Managers typically use files to store various types of
data, such as, log files, data files, etc. However, from the
perspective of a DBMS, the concept of a file is a logical one; all
the DBMS cares about is a named storage container that supports
random positioned IO. As long as this requirement is met, it is not
important whether a container maps to a file or to some other
device.

The objective of this package is to provide a level of abstraction
to the rest of the DBMS so that the mapping of a container to a file
becomes an implementation artefact. If desired, containers may be
mapped to raw devices, or to segments within a file.

\section{Storage Containers}
A Storage Container is a named entity that supports positioned
(random) Input/Output. The default implementation maps a container
to a file, but this is an implementation detail. The rest of the
system does not need to know what the storage container maps to.

In SimpleDBM, each table or index maps to a single storage
container. The Write Ahead Log also uses storage containers to store
its data. Table and index containers have fixed size pages. The
Write Ahead Log contains variable size records.

\section{Storage Container Registry}
Container names are usually not good identifiers for the rest of the
system. Integer identifiers are better, especially when other
objects need to refer to specific containers. Integers take less
amount of storage, and also remove the dependency between the
container's name and the rest of the system. To support this
requirement, the \verb|org.simpledbm.rss.api.st.StorageManager|
interface is provided, which maintains a mapping of
StorageContainers to integer identifiers. Note that the Storage
sub-system does not decide how to map the containers to ids; it
merely enables the registration of these mappings and allows
StorageContainer objects to be retrieved using their numeric
identifiers.

\begin{verbatim}
StorageContainerFactory storageFactory
    = new FileStorageContainerFactory();
StorageManager storageManager = new StorageManagerImpl();
StorageContainer sc = storageFactory.open("dual");
storageManager.register(0, sc);
\end{verbatim}

Above sample code registers the container named ``dual'' to the
storage manager and identifies this with the integer value 0. Other
modules may obtain access to the storage container as follows:

\begin{verbatim}
StorageContainer sc = storageManager.getInstance(0);
\end{verbatim}

\section{Storable Interface and Object serialization}
SimpleDBM requires some way of serializing and de-serializing
objects from a byte stream. Java provides the java.io.Serializable
interface and associated technology for this, however, the default
mechanism is unsuitable for use in SimpleDBM. The problem with the
default method is that the language decides how to map type
information to the stream. Since this has to be done in a generic
manner, it cannot be optimised for space. In contrast, SimpleDBM can
use the 2-byte short integer type code used in the Object Registry
module to efficiently store type information.

SimpleDBM provides the \verb|org.simpledbm.rss.api.st.Storable|
interface as a substitute for \verb|java.io.Serializable| interface.
\verb|Storable| interface requires the object to be able to predict
its stored size in bytes via the \verb|getStoredLength()| method. It
also requires the object to be able to stream itself to a
\verb|ByteBuffer| object, and also restore its contents from a
\verb|ByteBuffer| object.

\chapter{Latch Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.api.latch| & \verb|org.simpledbm.common.latch.impl| \\
\hline
\end{tabular}

\section{Overview}
A Latch is an efficient lock that is used by the system to manage
concurrent access to physical structures. In many ways, Latches are
similar to Mutexes, however, latches supports additional lock modes,
such as Shared locks and Update locks.

\section{Latch modes}
SimpleDBM implements two types of latches. A ReadWrite Latch
supports two lock modes:

Shared mode -- is compatible with Shared mode but incompatible with
Exclusive

Exclusive mode -- incompatible with any other mode.

A ReadWriteUpdate latch is an enhanced version that supports an
additional Update mode lock.

Update mode -- compatible with Shared mode but incompatible with
Update or Exclusive modes. Note that the Shared mode locks are
incompatible with Update mode locks.

An Update lock may be upgraded to Exclusive lock, and conversely, an
Exclusive lock may be downgraded to an Update lock. An Update lock
may also be downgraded to a Shared lock.

\section{Implementation and Performance Notes}
The SimpleDBM Latch interface is designed to be compatible with the
Java 5.0 ReentrantReadWriteLock interface. This allows the ReadWrite
Latch implementation to be based upon the Java primitive.

The ReadWrite Latch is likely to be more efficient than the
ReadWriteUpdate Latch.

\section{Obtaining a latch instance}
SimpleDBM implements a factory class for creating Latch objects. The
factory supports instantiating a ReadWrite latch, or a
ReadWriteUpdate latch. There is also a default mode which results in
ReadWrite latch.

\chapter{Log Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.common.log| & \verb|org.simpledbm.common.log.impl| \\
\hline
\end{tabular}

\section{Overview}
The Write Ahead Log plays a crucial role in a DBMS. It provides the
basis for recoverability. It is also a critical part of the system
that has a massive impact on performance of an OLTP system.

Conceptually, the Log can be thought of as an ever growing
sequential file. In the form of Log Records, the Log contains a
history of all changes made to the database. Each Log Record is
uniquely identified by a number called the Log Sequence Number
(LSN). The LSN is designed in such a way that given an LSN, the
system can locate the corresponding Log Record quickly. LSNs are
assigned in strict ascending order (monotonicity). This is an
important property when it comes to recovery.

During the progress of a Transaction, the a DBMS records in the Log
all the changes made by the transaction. The Log records can be used
to recover the system if there is a failure, or they can be used to
undo the changes made by a transaction.

Initially, Log Records are stored in memory. They are flushed to
disk during transaction commits, and also during checkpoints. In the
event of a crash, it is possible to lose the log records that were
not flushed to disk. This does not cause a problem, however, because
by definition these log records must correspond to changes made by
incomplete transactions. Also, the WAL protocol (described below)
ensures that such Log records do not contain changes that have
already been persisted within the database.

\section{Write Ahead Log (WAL) Protocol}
The WAL protocol requires the following conditions to hold true:

\begin{enumerate}
\item All changes made by a transaction must be recorded in the Log and the Log must be flushed to disk before the transaction is committed.
\item A database buffer page may not be modified until its modifications have been logged. A buffer page may not be saved to disk until all its associated log records have been saved to disk.
\item While the buffer page is being modified and the Log is being updated, an Exclusive latch (a type of fast lock) must be held on the page to ensure that order in which changes are recorded in the Log correspond to the order in which they were made.
\end{enumerate}
Consequences of above rules are:

\begin{enumerate}
\item If a Log Record was not saved to disk, it can be safely ignored, because any changes contained in it are guaranteed to belong to uncommitted transactions. Also, such Log Records cannot represent changes that have been made persistent in the database.
\item Log records represent changes to the system in the correct order. The latching protocol ensures that if two Log records represent changes to the same Page, then the ordering of these records reflects the order in which the changes were made to the page.
\end{enumerate}
\section{Advantages of WAL}
Typically, in an OLTP system, updates tend to be random and can
affect different parts of the disk at a point in time. In
comparison, writes to the Log are always sequential. If it were
necessary to flush all changes made by the DBMS to disk at commit
time, it would have a massive impact on performance because of the
randomness of the disk writes. However, in a WAL system, only the
Log needs to be flushed to disk at Commit. Thus, the Log has the
effect of transforming random writes into serial writes, thereby
improving performance significantly.

\section{Usage Notes}
The Log Manager interface does not make any assumptions about log
records. In fact, it does not specify the format of a log record.

\section{SimpleDBM Implementation of the Log}
The SimpleDBM Log maintains control information separately from log
files. For safety, multiple copies of control information are stored
(though at present, only the first control file is used when opening
the Log).

Logically, the Log is organized as a never ending sequence of log
records. Physically, the Log is split up into log files. There is a
fixed set of online log files, and a dynamic set of archived log
files. The set of online log files is called a Log Group.

Each Log Group consists of a set of pre-allocated log files of the
same size. The maximum number of groups possible is 3, and the
maximum number of log files within a group is 8. Note that each
group is a complete set in itself - the Log is recoverable if any
one of the groups is available, and if the archived log files are
available. If more than one group is created, it is expected that
each group will reside on a different disk sub-system.

The Log Groups are allocated when the Log is initially created. The
log files within a group are also pre-allocated. However, the
content of the online log files changes over time.

Logically, in the same way that the Log can be viewed as a sequence
of Log Records, it can also be thought of as a sequence of Log
Files. The Log Files are numbered in sequence, starting from 1. The
Log File sequence number is called LogIndex. At any point in time,
the physical set of online log files will contain a set of logical
log files. For example, if there are 3 physical files in a Log
Group, then at startup, the set of logical log files would be 1, 2
and 3. After some time, the log file 1 would get archived, and in
its place a new logical log file 4 would be created. The set now
would now consist of logical log files 2, 3 and 4.

When a log record is written to disk, it is written out to an online
log file. If there is more than one group, then the log record is
written to each of the groups. The writes happen in sequence to
ensure that if there is a write failure, damage is restricted to one
Log Group. Note that due to the way this works, having more than 1
group will slow down log writes. It is preferable to use hardware
based disk mirroring of log files as opposed to using multiple log
groups.

When new log records are created, they are initially stored in the
log buffers. Log records are written out to log files either because
of a client request to flush the log, or because of the periodic
flush event.

During a flush, the system determines which log file to use. There
is the notion of Current log file, which is where writes are
expected to occur. If the current log file is full, it is put into a
queue for archiving, and the log file is switched. Until an online
log file has been archived, its physical file cannot be reused. A
separate archive thread monitors archive requests and archives log
files in the background.

Only one flush is permitted to execute at any point in time.
Similarly, only one archive is permitted to execute at any point in
time. However, multiple clients are allowed to concurrently insert
and read log records, even while flushing and archiving is going on,
except under following circumstances.

\begin{enumerate}
\item Log inserts cannot proceed if the system has used up more
memory than it should. In that case, it must wait for some memory to
be freed up. To ensure maximum concurrency, the memory calculation
is approximate.
\item A Log flush cannot proceed if all the online log files are full.
In this situation, the flush must wait for at least one file to be
archived.
\item When reading a log record, if the online log file containing the
record is being archived, the reader may have to wait for the status
of the log file to change, before proceeding with the read.
Conversely, if a read is active, the archive thread must wait for
the read to be over before changing the status of the log file.
\end{enumerate}

If archive mode is ON, log files are archived before being re-used.
Otherwise, they can be reused if the file is no longer needed -
however this is currently not implemented. By default archive mode
is ON.

\subsection{Limitations of current design}
A Log record cannot span log files, and it must fit within a single
log buffer. Thus the size of a log record is limited by the size of
a log buffer and by the size of a log file. As a workaround to this
limitation, clients can split the data into multiple log records,
but in that case, clients are responsible for merging the data back
when reading from the Log.

\section{Creating a new Log Instance}
Several parameters must be supplied when creating a new log
instance. These are specified using a Java Properties object.

\begin{table}[h]
\begin{tabular}{|l|p{6cm}|}
\hline
  \textbf{Property Name}&\textbf{Description}  \\
\hline \verb|log.ctl.{n}|&The fully qualified path to the
  log control file. The first file should be specified as
\verb|log.ctl.1|, second as \verb|log.ctl.2|, and so on. Up to a
maximum of 3 can
be specified. Default is 2. \\
\hline
  \verb|log.groups.{n}.path|&The path where log
files of a group should be stored. The first log group is specified
as \verb|log.groups.1.path|, the second as \verb|log.groups.2.path|,
and so on. Up to a maximum of 3 log groups can be specified. Default
number of
groups is 1. Path defaults to current directory.  \\
\hline
  \verb|log.archive.path|&Defines the path for storing archive files. Defaults to current
directory.  \\
\hline
  \verb|log.group.files|&Specifies the number of log files within each group.
Up to a maximum of 8 are allowed. Defaults to 2. \\
\hline \verb|log.file.size|&Specifies the size of each log file in
bytes. Default is 2 KB. \\
\hline \verb|log.buffer.size|&Specifies the size of the log buffer
in bytes.
Default is 2 KB. \\
\hline \verb|log.buffer.limit|&Sets a limit on the maximum number of
log buffers that can be allocated. Default is 10 *
\verb|log.group.files|.  \\
\hline \verb|log.flush.interval|&Sets the interval (in seconds)
between log flushes. Default is 6 seconds.  \\
\hline
\end{tabular}
\label{tab2} \caption{Log Options}
\end{table}

Here is an example:

\begin{verbatim}
    LogFactory factory = new LogFactoryImpl();
    Properties properties = new Properties();
    properties.setProperty("log.ctl.1", "ctl.a");
    properties.setProperty("log.ctl.2", "ctl.b");
    properties.setProperty("log.groups.1.path", ".");
    properties.setProperty("log.archive.path", ".");
    properties.setProperty("log.group.files", "3");
    properties.setProperty("log.file.size", "16384");
    properties.setProperty("log.buffer.size", "16384");
    properties.setProperty("log.buffer.limit", "4");
    properties.setProperty("log.flush.interval", "30");
    factory.createLog(properties);
\end{verbatim}

\section{Opening a log instance}
Once a Log has been created, it can be opened for use. Opening the
log also starts back ground threads that handle periodic log flushes
and archival of log files. When the log is closed, the background
threads are shut down.

Following sample code shows how this is done:

\begin{verbatim}
    LogFactory factory = new LogFactoryImpl();
    Properties properties = new Properties();
    properties.setProperty("log.ctl.1", "ctl.a");
    properties.setProperty("log.ctl.2", "ctl.b");
    properties.setProperty("log.groups.1.path", ".");
    properties.setProperty("log.archive.path", ".");
    properties.setProperty("log.group.files", "3");
    properties.setProperty("log.file.size", "16384");
    properties.setProperty("log.buffer.size", "16384");
    properties.setProperty("log.buffer.limit", "4");
    properties.setProperty("log.flush.interval", "30");
    LogMgr log = factory.openLog(properties);
    try {
        // do some work
    } finally {
        if (log != null)
            log.close();
    }
\end{verbatim}

Note the use of finally block to ensure that the log is properly
closed.

\section{Inserting new log records}
The Log Manager does not care about the contents of the log record.
It treats the contents as a byte stream. This is illustrated in the
following example:

\begin{verbatim}
    LogMgr log = factory.openLog(null);
    try {
        String s = "hello world!";
        byte[] b = s.getBytes();
        Lsn lsn = log.insert(b, b.length);
    } finally {
        if (log != null)
            log.close();
    }
\end{verbatim}

Each new log record is assigned a unique sequence number known as
the Log Sequence Number (LSN). This can be used later on to retrieve
the log record.

\section{Flushing the Log}
When new log records are created, initially they are stored in the
Log Buffers. The log records are flushed to disk either upon request
or by the background thread that periodically flushes the Log.
Clients can request the log to be flushed upto a specified LSN. Note
that this is a blocking call, i.e., the client will be blocked until
the flush is completed.

Example:

\begin{verbatim}
    String s = "hello world!";
    byte[] b = s.getBytes();
    Lsn lsn = log.insert(b, b.length);
    log.flush(lsn);
\end{verbatim}

Typically, flush requests are issued by Transaction Manager, when a
transaction commits or aborts, or by the Buffer Manager when it is
about to write a dirty buffer.

\section{Reading Log records}
Log records can be read individually or using a scan. The Log
Manager allows both forward and backward scans of the Log. A
starting LSN can be specified; if this is not specified then the
scanning will begin from the first or last record, depending upon
whether it is a forward or backward scan.

Shown below is an example of directly accessing a log record by its
LSN:

\begin{verbatim}
    Lsn myLsn = ...;
    LogRecord logrec = log.read(myLsn);
    byte[] data = logrec.getData();
\end{verbatim}

Shown below is an example of using the Log Scan facility:

\begin{verbatim}
    void readAllRecords(LogMgr log) throws Exception {
        LogReader reader = log.getForwardScanningReader(null);
        try {
            for (;;) {
                LogRecord rec = reader.getNext();
                if (rec == null) {
                    break;
                }
                printRecord(rec);
            }
        }
        finally {
            if (reader != null)
                reader.close();
        }
    }
\end{verbatim}

\section{Checkpoint Records}
In transactional systems there is often a need to maintain special
checkpoint records that contain a snapshot of the system at a point
in time. Checkpoint records can be handled in the same way as normal
log records, however, the Log Manager also maintains information
about the most recent checkpoint record. Whenever a checkpoint
record is written, the Log Manager should be informed about its LSN.
This ensures that at the next flush, the Log Control files are
updated.

\begin{verbatim}
    CheckpointRecord checkpointRec = new CheckpointRecord();
    Lsn checkpointLsn = log.insert(checkpointRec.getData(),
            checkpointRec.getLength());
    logmgr.setCheckpointLsn(checkpointLsn);
    logmgr.flush(checkpointLsn);
\end{verbatim}

The LSN of the last checkpoint record can be retrieved at any time
using the getCheckpointLsn() method. Note that if the Checkpoint
Record is too large and needs to be broken up into smaller records,
then the checkpointLsn should be set to the first checkpoint record.

\chapter{Lock Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.api.locking| & \verb|org.simpledbm.rss.locking.impl| \\
\hline
\end{tabular}

\section{Introduction}
All multi-user transactional systems use some form of locking to
ensure that concurrent transactions do not conflict with each other.
Depending upon the level of consistency guaranteed by the
transactional system the number and type of locks used can vary.

In a single user system, no locking is needed. Transaction are
automatically consistent, as only one transaction can execute at any
point in time.

\section{Locking Basics}
In multi-user systems, transactions must be allowed to proceed
concurrently if reasonable performance is to be obtained. However,
this means that unless some form of locking is used, data
consistency problems will arise. For example, if two transactions
update the same record at the same time, one of the updates may be
lost.

To prevent this sort of thing from happening, each transaction must
lock the data that it updates or reads. A lock is a mechanism by
which access to the record is restricted to the transaction that
owns the lock. Furthermore, a lock restricts the type of operation
that is permitted to occur. For example, a Shared lock can be owned
by multiple transactions concurrently and allows read operations. An
Exclusive lock permits both read and write operations but can only
be granted to one transaction at any point on time. Moreover Shared
locks and Exclusive locks are incompatible; this means that if a
Shared Lock is held by a transaction on a record, another
transaction cannot obtain an Exclusive lock on the same record, and
vice-versa.

\section{Two-Phase Locking and Repeatable Read Isolation Level}
Not only must a record be locked when it is updated, the transaction
must hold the lock until the transaction is committed or aborted.
This strategy leads to the basic rule of two-phase locking, which
requires that a transaction must manage its locks in two distinct
phases. In the first phase, the transaction is permitted to acquire
locks, but cannot release any locks. The first phase lasts right up
to the moment the transaction is completed, i.e., either committed
or aborted. In the second phase, when the transaction is committed
or aborted, all locks are released. No further locks can be acquired
in this phase. Strict two phase locking ensures that despite
concurrent running of transactions, each transaction has the
appearance of running in isolation. Strict two-phase locking
strategy provides a level of consistency called Repeatable Read.

\section{Read Committed Isolation Level}
This basic strategy can be modified to obtain greater concurrency at
the cost of data consistency. For example, read locks can be
released early to allow other transactions to read data. While this
increases concurrency, it does mean that reads are not repeatable,
because the original transaction may find that the data it read
previously has been modified by the time it is read a second time.
This level of consistency is known as Read Committed.

\section{Serializable Isolation Level}
Although the Repeatable Read level of consistency prevents data that
has been read by one transaction from being modified by another, it
does not prevent the problem of phantom reads, which occurs when new
records are inserted. For example, if a range of records is read
twice by the same transaction, and another transaction has inserted
new records in the time interval between the two reads, then the
second read will encounter records that did not appear the first
time. To prevent this type of phantom reads from occurring, locking
has to be made even more comprehensive. Rather than locking one
record, certain operations need to lock entire ranges of records,
even non-existent ones. This is typically achieved using a logical
convention; a lock on a particular data item represents not only a
lock on that data, but also the range of data up to and including
the data item being locked. For example, if there are two records A
and C, then a lock on C would encompass the entire range of data
between A and C, excluding A, but including and up to C.

\section{Design choices}
The Locking subsystem specified in SimpleDBM requires that locks
should be implemented independently of the objects being locked. In
order for locking to work, all participants must agree to agree to
use the locking system and abide by the rules.

Another design constraint is that the interface is geared towards a
memory based implementation. This places a constraint on the number
of locks that can be held within the system, because a large number
of locks would require a prohibitively large amount of memory.

Some database systems, Oracle, in particular, use markers within the
databases disk pages to represent locks. A lock byte is used, for
instance, to denote whether a row is locked or not. The advantage of
Oracle's approach is that there are no constraints on the number of
locks the system can handle. The disadvantage is that the lock
status is maintained in persistent storage, therefore changing the
lock status can make a page dirty. Oracle overcomes this issue in
two ways. Firstly, it uses a multi-version system that does not
required read locks. Thus, locks are used only for updates, and
since updates cause database pages to be touched anyway, using a
lock status byte does not pose a problem. Secondly, Oracle avoids
updating the lock status byte when locks are released, by using
information about the transaction status to infer that a lock has
been released.

The interface for the Locking System specified in this package does
not support implementations of the type used in Oracle.

In some systems, locking is based upon facilities provided by the
underlying operating system. For instance, most operating systems
support some form of file locking. Since database records are laid
out into regions within a file system, file system locks can be
applied on records. No major database system does this, however.
This is because locking a region in the file would prevent all
access to that region, which would cause other problems. Even when
systems do use file system locks, typically, some form of logical
locking is used. For example, in DBASE III based systems, a single
byte in the file represents a record lock. In general, relying upon
file system locks can be source of numerous problems, such as
portability of the system, performance, etc.

\section{Lock Modes}
The SimpleDBM Lock Manager supports the following Lock Modes:

\begin{itemize}
\item INTENTION{\_}SHARED - Indicates the intention to read data at a lower level of granularity.
\item INTENTION{\_}EXCLUSIVE - Indicates the intention to update data at a lower level of granularity.
\item SHARED - Permits readers.
\item SHARED{\_}INTENTION{\_}EXCLUSIVE - Indicates SHARED lock at current level and intention to update data at a lower level of granularity.
\item UPDATE - Indicates intention to update, Permits readers.
\item EXCLUSIVE - Prevents access by other users.
\end{itemize}
\subsection{Lock Compatibility Matrix}
The lock compatibility matrix for above is given below:

\begin{table}[h]
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline Mode&NONE&IS&IX&S&SIX&U&X \\
\hline NONE& Y& Y& Y& Y& Y& Y& Y \\
\hline Intent Shared (IS)& Y& Y& Y& Y& Y& N& N \\
\hline Intent Exclusive (IX)& Y& Y& Y& N& N& N& N \\
\hline Shared (S)& Y& Y& N& Y& N& N& N\\
\hline Shared Intent Exclusive (SIX)& Y& Y& N& N& N& N& N \\
\hline Update (U)& Y& N& N& Y& N& N& N \\
\hline Exclusive (X)& Y& N& N& N& N& N& N\\
\hline
\end{tabular}
\label{tab3} \caption{Lock Compatibility Matrix}
\end{table}

\section{Lock Conversions}
SimpleDBM's Lock Manager also supports Lock Conversions. The
following table shows how lock conversions are handled:

\begin{table}[h]
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline Mode &NONE &IS &IX &S &SIX &U &X \\
\hline NONE &NONE &IS &IX &S &SIX &U &X \\
\hline Intent Shared (IS) &IS &IS &IX &S &SIX &U &X \\
\hline Intent Exclusive (IX) &IX &IX &IX &SIX &SIX &X &X \\
\hline Shared (S) &S &S &SIX &S &SIX &U &X \\
\hline Shared Intent Exclusive (SIX) &SIX &SIX &SIX &SIX &SIX &SIX
&X \\
\hline Update (U) &U &U &X &U &SIX &U &X \\
\hline Exclusive (X) &X &X &X &X &X &X &X \\
\hline
\end{tabular}
\label{tab4} \caption{Lock Conversion Matrix}
\end{table}

\section{Obtaining an instance of Lock Manager}
SimpleDBM provides a factory class for generating instances of the
Lock Manager. Note that locks are meaningful only within an instance
of the Lock Manager -- if there are two Lock Manager instances, each
will have its own set of locks.

Following sample code shows how to obtain an instance of the Lock
Manager.

\begin{verbatim}
    LockMgrFactory factory = new LockMgrFactoryImpl();
    Properties props = new Properties();
    props.setProperty("lock.hash.size", "193");
    LockMgr lockmgr = factory.create(props);
\end{verbatim}

The only property that can be set is the Hash Table size.

\section{Lockable objects}
Any object can be locked. The only requirement is that the object
should implement the \verb|hashCode()| and \verb|equals()| methods.
For the system to work correctly, lockable objects should be
immutable -- once created they must not be modified. Clearly, if the
object is modified while it is referenced in the lock tables, then
the system will malfunction, as the object will no longer respond to
\verb|hashCode()| and \verb|equals()| in a consistent manner.

\section{Lock Owners}
Every lock must have an owner. The LockMgr interface allows any
object to be lock owner; the only requirement is that the object
must implement the \verb|equals()| method.

\section{Lock Durations}
Locks can be acquired for an \verb|INSTANT_DURATION| or
\verb|MANUAL_DURATION|. Instant duration locks are not acquired in
reality -- the caller is delayed until the lock becomes available.
Manual duration locks are held until they are released. Such locks
have a reference count attached to them. If the lock is acquired
more than once, the reference count is incremented. The lock will
not be released until the reference count becomes zero.

Typically, a Transaction will hold locks until the transaction ends.
In some cases, SHARED locks may be released early, for example, in
the READ COMMITTED Isolation Level.

\section{Acquiring and releasing locks}
Locks can be acquired using the \verb|acquire()| method provided by
the LockMgr interface. The acquire method returns a Handle to the
lock, which can be used subsequently to release the lock. Example:

\begin{verbatim}
    LockMgr lockmgr = new LockMgrImpl(71);
    Object owner = new Integer(1);
    Object lockname = new Integer(10);
    LockHandle handle = lockmgr.acquire(owner, lockname,
        LockMode.EXCLUSIVE, LockDuration.MANUAL_DURATION, -1);
    // do some work
    handle.release(false);
\end{verbatim}

\section{Limitations in current implementation}
The biggest limitation is the lack of a Deadlock Detector. SimpleDBM
uses lock timeout as a workaround to this problem.

\chapter{Page Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.pm| & \verb|org.simpledbm.rss.pm.impl| \\
\hline
\end{tabular}

\section{Overview of Page Manager module}
The storage unit of a database system is a contiguous set of bytes
known as a Page. In SimpleDBM, pages are contained with logical
units called Storage Containers. The default implementation maps
containers to Operating System files.

A page is typically a fixed size block within the storage container.
The Page Manager module encapsulates the knowledge about how pages
map to containers. It knows about page sizes, and also knows how to
read/write pages from storage containers. By isolating this
knowledge into a separate module, the rest of the system is
protected. For example, the Buffer Manager module can work with
different paging strategies by switching the Page Manager module.

Note that the Page Manager module does not worry about the contents
of the page, except for the very basic and common stuff that must be
part of every page, such as page Id, page LSN, and page type. It is
expected that other modules will extend the basic page type and
implement additional features. The Page Manager does provide the
base class for all Page implementations. It also provides a generic
factory class that can instantiate pages of different types.

\section{Interactions with other modules}
The Buffer Manager module uses the Page Manager module to read/write
pages from storage containers and also to create new instances of
pages.

The Page Manager module requires the services of the Object Registry
module in order to create instances of pages from type codes.

Page Manager module also interacts with the Storage Manager module
for access to Storage Containers.

Each page is allocated a Latch to manage concurrent access to it.
The Page Manager therefore requires the services of the Latch
Manager.

\section{Page base class}
The page manager implements an abstract Page class that is the root
of the Page hierarchy. All other page types derive from this class.
The simplest of Page classes that one could create is shown below:

\begin{verbatim}
public class RawPage extends Page {
    public RawPage() {
        super();
    }
    @Override
    public void init() {
        // does nothing
    }
}
\end{verbatim}

\section{Page Size and implementation of Storable interface}
The Page class implements the Storable interface. However, unlike
other implementations, a Page has a fixed length which is defined by
the Page Factory responsible for creating it. The Page obtains the
page size from the Page Factory instance and uses that to determine
its persistent size. Sub-classes cannot change this value. This
means that the page size of all pages managed by a particular Page
Factory instance is always the same.

Sub-classes of course still need to implement their own store() and
retrieve() methods. These methods should always invoke their super
class counterparts before processing local content.

Example:

\begin{verbatim}
public class RawPage extends Page {
    int i;
    public RawPage() {
        super();
    }
    @Override
    public void init() {
        i = 0;
    }
    @Override
    public void store(ByteBuffer bb) {
        super.store(bb);
        bb.putInt(i);
    }
    @Override
    public void retrieve(ByteBuffer bb) {
        super.retrieve(bb);
        i = bb.getInt();
    }
}
\end{verbatim}

\section{How various Page types are managed}
SimpleDBM modules do not know in advance what page types are to be
used. Some of the modules define their own page types. However,
despite this the Buffer Manager, and the Transaction Manager modules
must handle pages, even read and write them to the disk as
necessary. This is made possible as follows:

\begin{enumerate}
\item Each Page type is given a typecode in the Object Registry. This allows the Page Factory to obtain instances of specific Page types given the typecode.
\item The typecode is stored in the first two bytes (as a short integer) of the Page when the page is persisted. When reading a page, the first two bytes are inspected to determine the correct Page type to instantiate. Reading and writing various page types is managed by the Page Factory implementation.
\item The Buffer Manager uses the Page Factory implementation to generate new instances of Pages or to read/write specific pages.
\item The abstract Page class provides a common interface for all Pages. This interface implements all the functionality that is required by the Transaction Manager module to manage updates to pages.
\end{enumerate}

\section{Page Factory}
Creating a page factory is relatively simple:

\begin{verbatim}
    StorageContainerFactory storageFactory =
        new FileStorageContainerFactory();
    ObjectFactory objectFactory = new ObjectFactoryImpl();
    StorageManager storageManager = new StorageManagerImpl();
    LatchFactory latchFactory = new LatchFactoryImpl();
    PageFactory pageFactory = new PageFactoryImpl(objectFactory,
        storageManager, latchFactory);

\end{verbatim}

Note that the Page Factory requires access to the Object Registry,
the Latch Manager and the Storage Manager.

\section{Storing and retrieving Pages}
Before pages can be stored or retrieved, the appropriate Storage
Containers must be created/opened and registered with the Storage
Manager. Also, the Page types must be registered with the Object
Registry. Following sample code shows how this may be done:

\begin{verbatim}
    String name = "testfile.dat";
    // Create a new storage container called testfile.dat
    StorageContainer sc = storageFactory.create(name);
    // Assign it a container ID of 1
    storageManager.register(1, sc);
    // Register the Page Type
    objectFactory.register("mypage", TYPE_MYPAGE, MyPage.class.getName());
    // Create a new instance of the page
    MyPage page = (MyPage) pageFactory.getInstance("mypage", new PageId(1,
        0));
    // Store the page in the container
    pageFactory.store(page);
    // Retrieve the page from the container
    page = (MyPage) pageFactory.retrieve(new PageId(1, 0));
\end{verbatim}

\chapter{Buffer Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.bm| & \verb|org.simpledbm.rss.bm.impl| \\
\hline
\end{tabular}

\section{Overview}
The Buffer Manager is a critical component of any DBMS. Its primary
job is to cache disk pages in memory. Typically, a Buffer Manager
has a fixed size Buffer Pool, implemented as an array of in-memory
disk pages. The contents of the Buffer Pool change over time, as
pages are read in, and written out. One of the principle tasks of
the Buffer Manager is to decide which page should stay in memory,
and which should not. The aim is to try to keep the most frequently
required pages in memory. The efficiency of the Buffer Manager can
be measured by its cache hit-rate, which is the ratio of pages found
in the cache, to pages accessed by the system.

In order to decide which pages to maintain in memory, the Buffer
Manager typically implements some form of Least Recently Used (LRU)
algorithm. In the simplest form, this is simply a linked list of all
cached pages, the head of the list representing the least recently
used page, and the tail the most recently used. This is based on the
assumption that if a page was accessed recently, then it is likely
to be accessed again soon. Since every time a page is accessed, it
is moved to the MRU end of the list, therefore over time, the most
frequently accessed pages tend to accumulate on the MRU side. Of
course, if a client reads a large number of temporary pages, then
this scheme can be upset. To avoid this, the Buffer Manager may
support hints, so that a client can provide more information to the
Buffer Manager, which can then use this information to improve the
page replacement algorithm. An example of such a hint would be to
flag temporary pages. The Buffer Manager can then use this knowledge
to decide that instead of the page going to MRU end, it goes to the
LRU end.

\section{Interactions with other modules}
The Buffer Manager interacts with the Log Manager and the Page
Manager modules. It needs the help of the PageFactory in order to
instantiate new pages, read pages from disk, and write out dirty
pages to disk. In order to support the Write Ahead Log protocol, the
Buffer Manager must ensure that all logs related to the page in
question are flushed prior to the page being persisted to disk.

The Transaction Manager also interacts with the Buffer Manager.
During checkpoints, the Transaction Manager asks for a list of dirty
pages. It uses information maintained by the Buffer Manager to
determine where recovery should start. After a system restart the
Transaction Manager informs the Buffer Manager about the recovery
status of disk pages.

\section{Creating a Buffer Manager instance}
A Buffer Manager instance has a dependency on Log Manager and Page
Factory. These in turn depend upon a few other modules. The
following sample code illustrates the steps required to create a
Buffer Manager instance.

\begin{verbatim}
    LogFactory factory = new LogFactoryImpl();
    Properties properties = new Properties();
    properties.setProperty("log.ctl.1", "ctl.a");
    properties.setProperty("log.ctl.2", "ctl.b");

    // Create Storage Factory instance
    StorageContainerFactory storageFactory =
        new FileStorageContainerFactory();
    // Open Log
    LogMgr log = factory.openLog(storageFactory, properties);
    // Create Object Registry
    ObjectFactory objectFactory = new ObjectFactoryImpl();
    // Create Storage Manager instance
    StorageManager storageManager = new StorageManagerImpl();
    // Create Latch Factory
    LatchFactory latchFactory = new LatchFactoryImpl();
    // Create Page Factory
    PageFactory pageFactory = new PageFactoryImpl(objectFactory,
        storageManager, latchFactory);
    // Create a Buffer Manager intance with a Buffer Pool of
    // 50 pages and a hash table of 101 buckets
    BufMgrImpl bufmgr = new BufMgrImpl(logmgr, pageFactory, 50, 101);
\end{verbatim}

Note that when creating a Buffer Manager instance, you can set the
size of the Buffer Pool and also the size of the Hash table.

A Buffer Manager instance has a one to one relationship with a Page
Factory. Hence all pages managed by the Buffer Manager instance will
be of the same size; the page size is determined by the Page
Factory.

\section{Fixing Pages in the Buffer Pool}
The Buffer Manager provides methods for fixing pages in the Buffer
Pool. There are two possibilities:

\begin{enumerate}
\item Fix a new page.
\item Fix an existing page.
\end{enumerate}

It is the client's responsibility to know whether the page is new or
existing. If a request is made to fix the page as new, then the
outcome may be unexpected. If the page already exists in the Buffer
Pool, it will be returned, rather than initializing a new Page.

When fixing a Page, the Page can be locked in one of three modes:

\begin{enumerate}
\item Shared mode -- allowing multiple clients to access the same Page concurrently for reading.
\item Update mode -- which allows one client to access the page in update mode, but other clients may access the same page concurrently in Shared mode.
\item Exclusive mode -- in this mode only one client has access to the Page. This mode is used when a client wishes to modify the contents of the Page.
\end{enumerate}

An Update mode request can be upgraded to Exclusive mode. An
Exclusive mode request may be downgraded to an Update mode request.

Following code sample shows how page is fixed:

\begin{verbatim}
// Fix page as New (the second parameter). The page type is mypage.
// This page type should have been registered with the Object Registry
// prior to this call. The page will be latched in Exclusive mode.
// The last parameter is a hint for the LRU replacement algorithm.
BufferAccessBlock bab = bufmgr.fixExclusive(new PageId(1, 0),
    true, "mypage", 0);
\end{verbatim}

As shown above, when a page is fixed, the Buffer Manager returns a
BufferAccessBlock which contains a reference to the desired page.
The Page can be accessed as follows:

\begin{verbatim}
    MyPage page = (MyPage) bab.getPage();
\end{verbatim}

\section{Modifying page contents}
Note that in order to modify a Page's content, the Page must be
fixed in Exclusive mode.

Also, the Write Ahead Log protocol must be obeyed. This requires the
modification to proceed as follows:

\begin{enumerate}
\item Fix the page in exclusive mode.
\item Generate a log record containing redo/undo information for the modification about to be made.
\item Modify the page contents.
\item Set the Page LSN of the page and mark the page as dirty.
\item Unfix the page.
\end{enumerate}
Failure to follow this protocol may lead to unrecoverable changes.

\section{Changing lock modes}
As mentioned before, pages that are locked in Update mode may be
upgraded to Exclusive mode. Pages that are locked in Exclusive mode
may be downgraded to Update mode. The BufferAccessBlock interface
provides methods that allow the lock mode to be upgraded or
downgraded.

\section{Unfixing a Page}
It is very important to unfix a Page after the client is done with
it. Failure to do so may cause the Buffer Pool to become full and
the system will potentially come to a halt if further pages cannot
be fixed. A fixed page cannot be removed from the Buffer Pool.

It is also advisable to keep pages fixed for a short duration only.
If necessary the same page can be fixed again.

\chapter{Transaction Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.tm| & \verb|org.simpledbm.rss.tm.impl| \\
\hline
\end{tabular}

\section{Introduction}
The Transaction Manager is responsible for managing transactions. It
provides interfaces for starting new transactions, and for
committing or aborting transactions. The SimpleDBM implementation
also supports Savepoints. While the view seen by the user is simple,
the Transaction Manager is a complex module and has an elaborate
interface. This chapter will attempt to unravel the TM interface and
with the help of examples, demonstrate how this interface works and
how other modules can use this interface to participate in
Transactions.

\section{Overiew}
SimpleDBM's transaction manager is modelled after ARIES. It makes
following assumptions about the rest of the system:

\begin{enumerate}
\item The system uses the Write Ahead Log protocol when making changes to database containers.
\item The unit of change is a disk page. This means that logging is on a per page basis.
\item The disk page contains a PageLSN field that can be used to track the last log record that made changes to the page.
\item During checkpoints the Transaction Manager does not flush all pages, instead it writes the Buffer Manager's ``table of contents'' to the Log. The table of contents is the list of dirty pages in the Buffer Pool, along with their Recovery LSNs. The Recovery LSN is the LSN of the oldest log record that could potentially have have a change to the page. For a discussion of the Recovery LSN please refer to Mohan's paper on ARIES and also to section 13.4.4.1 of \textit{Transaction Processing: Concepts and Techniques}. The TPCT book refers to Recovery LSNs as \textsf{forminlsn}.
\item At the end of system restart, the Transaction Manager informs the Buffer Manager the RecoveryLSN status of all dirty pages; the Buffer Manager must therefore provide an interface for updating the Recovery LSN of such pages.
\item The Log Manager provides a mechanism for reliably recording the Checkpoint LSN. Also, the Log Manager supports accessing Log Records sequentially from a starting point, as well as randomly using the LSN.
\item The Lock Manager provides an interface for acquiring and release locks. The release mode must support a mechanism for forcing the release of a lock.
\end{enumerate}
\section{What is ARIES?}
ARIES is a Transaction Logging and Recovery algorithm developed at
IBM and published by IBM researcher C. Mohan.

For a full description of ARIES, please see \textit{Mohan, C.,
Haderle, D., Lindsay, B., Pirahesh, H., Schwarz, P. ARIES: A
Transaction Recovery Method Supporting Fine-Granularity Locking and
Partial Rollbacks Using Write-Ahead Logging, ACM Transactions on
Database Systems, Vol. 17, No. 1, March 1992, pp94-162.}

A brief overview of ARIES is given below.

\subsection{ARIES - An Overview}
Following is a brief description of the main principles behind
ARIES.

Firstly, in ARIES, changes always take the system forward. That is
to say, even transaction rollbacks are treated as if they are
updates to the system. This is counter-inituitive to what the user
thinks, because when a user asks for a transaction to be rolled
back, they assume that the system is going back to a previous state
of affairs. However, from the perspective of ARIES, there is no such
thing as going back. For example, if a transaction changes A to B
and then rolls back, ARIES treats the rollback as simply an update
that changes B to A. The forward change from A to B (redo) and the
reversal of B to A (undo) are both recorded as updates to the
system. Changes during normal operations are recorded as Redo-Undo
log records. As the name implies, these log records can be 'redone'
in case of a system crash, or 'undone' in case a rollback is
required. Changes made during rollbacks, however, are recorded as
Redo-only log records. These log records are called Compensation Log
Records (CLRs). The reason these are redo only is that by definition
a rollback does not need to be undone, whereas normal updates need
to be undone if the transaction decides to rollback.

The second basic principle of ARIES is that during recovery, history
is repeated. This can be explained as follows.

When a system crashes, there would be some transactions that have
completed (committed or aborted), and others that are still active.
The WAL protocol ensures that changes made by completed transactions
have been recorded in the Log. Changes made by incomplete
transactions may also be present in the Log, because Log Records are
created in the same order as the changes are made by the system.

During recovery, ARIES initially replays the Log to the bring the
system back to a state close to that when the crash occurred. This
means that ARIES replays the effects of not only those transactions
that committed or aborted, but also those that were active at the
time of the crash. Having brought the system to this state, ARIES
then identifies transactions that were incomplete, and rolls them
back. The basic idea is to repeat the entire history upto the point
of crash, and then undo failed transactions.

This approach has the advantage that during the redo phase, changes
can be replayed at a fairly low level, for example, the level of a
disk page. ARIES calls this page oriented redo. This feature is
significant because it means that until the redo phase is over, the
system does not need to know about higher level data structures such
as Indexes. Only during the undo phase, when incomplete transactions
are being rolled back, does the system need to know about high level
data structures.

\subsection{Features of ARIES}
ARIES includes a number of optimisations to reduce the amount of
work required during normal operations and recovery.

One optimisation is to avoid application of log records
unnecessarily. The LSN of the most recently generated log record is
stored in each disk page. This is known as the PageLsn. The PageLsn
allows ARIES to determine during the redo phase, whether the changes
represented by a log record have been applied to the page or not.

ARIES chains log records for transactions in such a way that those
records that are no longer necessary, are skipped during recovery.
For example, if a transaction changed A to B, and then rolled back,
generating a log record for changing B to A, then during recovery,
ARIES would automatically skip the log record that represents the
change from A to B. This is made possible by maintaining a UndoLsn
pointer in every Log Record. The UndoLsn normally points to the
previous log record generated by the transaction. However, in log
records generated during Rollback (known as Compensation Log
Records), the UndoLsn is made to point to the Log record preceding
the one that is being undone. To take an example, let us assume that
a transaction generated log record 1, containing change from A to B,
then log record 2 containing change from B to C. At this point the
transaction decides to rollback the change from B to C. It therefore
generates a new log record 3, containing a change from C to B. The
UndoLsn of this log record is made to point at log record 1, instead
of log record 2. When following the UndoLsn chain, ARIES would skip
log record 2.

ARIES also supports efficient checkpoints. During a checkpoint, it
is not necessary to flush all database pages to disk. Instead ARIES
records a list of dirty buffer pages along with their
RecoveryLsn(s). The RecoveryLsn of a page is the LSN of the earliest
log record that represents a change to the page since it was read
from disk. By using this list, ARIES is able to determine during
recovery, where to start replaying the Log.

ARIES supports nested top-level action concept whereby part of a
transaction can be committed even if the transaction aborts. This is
useful for situations where a structural change should not be undone
even if the transaction aborts. Nested top level actions are
implemented using Dummy Compensation Log Records - and make use of
the ability to skip logs records using the UndoLsn pointer as
described previously.

\section{Transactions and Locks}
There is close coordination between the Transaction Manager and the
Lock Manager. A Transaction needs to keep track of all locks
acquired on its behalf so that it can release them when the
Transaction completes. This is why the Transaction interface in
SimpleDBM provides methods for acquiring locks. If the Lock Manager
is invoked directly by the client then the TM has no way of knowing
which locks to release when the Transaction terminates.

While locks can be acquired by a client any time after a Transaction
starts, locks are released only on one of the following three
occasions:

\begin{enumerate}
\item If the CURSOR STABILITY Isolation Mode is being used, then a SHARED or UPDATE lock can be released once the cursor moves to the next record. If REPEATABLE READ Isolation Mode is used, then the UPDATE lock can be downgraded to SHARED lock when the cursor moves. Note that the Transaction Manager does not decide when to release or downgrade a lock; it is the responsibility of the client to decide that. However, the Transaction must update its record of the locks when this happens. Therefore, lock release or downgrade requests must be handled via the Transaction interface and not directly between the client and the Lock Manager.
\item When a Transaction is rolled back to a Savepoint, any locks acquired after the Savepoint are released. Note that if a lock was acquired before the Savepoint, and upgraded after the Savepoint, it will not be downgraded or released. The Transaction interface manages the release of such locks.
\item Finally, when the Transaction completes, all locks held by the transaction are released.
\end{enumerate}
Following sample code shows how a client interacts with the
Transaction.

\begin{verbatim}
// Start new Transaction
Transaction trx = trxmgr.begin();

// Acquire a shared lock
trx.acquireLock(new ObjectLock(1,15), LockMode.SHARED,
    LockDuration.MANUAL_DURATION);

// Upgrade the shared lock
trx.acquireLock(new ObjectLock(1,15), LockMode.UPDATE,
LockDuration.MANUAL_DURATION);

// Downgrade the update lock
trx.downgradeLock(new ObjectLock(1, 15),
    LockMode.SHARED);

// commit the transaction, releasing all locks
trx.commit();
\end{verbatim}

\section{Transactions and Modules}
The Transaction Manager provides a framework for managing
transactions. It provides interfaces to:

\begin{itemize}
\item Start and end transactions
\item Acquire locks on behalf of transactions
\item Create log records on behalf of transactions.
\end{itemize}
The Transaction Manager itself does not initiate changes to database
pages, though it may coordinate the redo or undo of such changes --
changes are always initiated by clients. A client in this context is
some module within the system that wishes to make changes to the
database disk pages as part of a Transaction.

The Transaction Manager does not know in advance what clients it may
have to interact with. However, it needs to be able to call upon the
clients to redo or undo the effects of log records when required.
This is enabled in two ways:

\begin{itemize}
\item Firstly, all clients must implement the TransactionalModule interface. This interface defines the operations that the Transaction Manager may call upon the client to perform.
\item Secondly, all modules must ``register'' themselves to the Transaction Manager using unique Module IDs. This way, the Transaction Manager knows how to obtain access to a module, and ask it to perform an action.
\item Finally, all log records generated by a Module need to be tagged with the Module's Unique ID. If this is not done, the Transaction Manager would not know which module is responsible for handling a particular log record.
\end{itemize}
\section{Transactions and Log records}
The Transaction Manager works very closely with the Log Manager to
ensure the ACID properties of transactions. We saw in the chapter on
Log Manager that it does not care about the contents of Log Records.
The Transaction Manager, however, does care, and defines a hierarchy
of different Log record types that should be used by clients. This
is explained below.

\subsection{The Loggable hierarchy}
Loggable is parent interface for all Log Records. The Transaction
Manager will only accept Log records that implement this interface.
This can be seen from the signature of the logInsert() method
provided by the Transaction interface.

The Loggable hierarchy defines the various types of log records that
clients can generate. These are further discussed below.

\subsection{Loggable Hierarchy}
The main branches of the Loggable hierarchy are shown below. Note
that some of the hierarchy is not visible to outside clients (marked
as internal).

\begin{table}[tbp]
\begin{tabular}{|l|p{6cm}|}
\hline Interface&Description \\
\hline \verb|Redoable|&All log operations that affect database pages
must implement this interface or one of its sub-interfaces. The
Transaction Manager expects a valid PageId (s) to be returned by a
Redoable log record. Note that Compensation and Undoable log records
are sub-interfaces of Redoable. \\
\hline \verb|NonTransactionRelatedOperation|&These represent changes
that are not related to specific pages. Since the ARIES algorithm
uses page LSNs to track updates caused by log records, changes made
by this type of log record are not tracked  they are repeated
unconditionally at system start. At present, this type of log
operation is used to handle opening of containers.\\
\hline \verb|PostCommitAction|&Although PostCommitAction is a
subinterface of NonTransactionRelatedOperation at present, this may
change in future. PostCommitActions are used to schedule actions
that must be performed after a successful commit. An example of such
an action is the dropping of a container. To avoid logging the full
contents of the container, the actual delete of the container must
be deferred until it is certain that the Transaction is committing.
Note that unlike other NonTransactionRelatedOperations, the
Transaction Manager does track the status of PostCommitActions and
will execute them at restart if they have not been executed. \\
\hline \verb|ContainerDeleteOperation|&The Transaction Manager needs
to be aware when containers are deleted, both when a container is
dropped or when the creation of a container is aborted. In both
cases, the TM uses this marker interface to identify the delete
operation and coordinates with the Buffer Manager to clear the
cached pages related to the deleted container. \\
\hline
\end{tabular}
\caption{Loggable Hierarchy}
\end{table}
\clearpage

\subsection{Transaction Manager Internal Log Records}
The Transaction Manager uses internal log records to track
Transaction completion, and also Checkpoints. These log record types
are not available outside the implementation of the TM.

\subsection{Redoable}
Generally speaking, most log records are implementations of Redoable
interface or one of its sub-interfaces. A Redoable log record is
related to one or more database pages, and can be re-done at System
restart. In some cases, the effects of a log record should not be
undone; such records are called Redo-only log records and can be
created in a number of ways:

\begin{enumerate}
\item Implement the Redoable interface but not its Undoable sub-interface.
\item Implement the Compensation interface. This is a special case, which is discussed later.
\end{enumerate}
An example of a Redo-only log record is the Page Format operation.
Newly created pages need to be formatted, but once this is done, it
is unnecessary to undo the formatting.

Given below is an example implementation of a Page Format log
record:

\begin{verbatim}
    public static class FormatRawPage extends BaseLoggable
    implements Redoable, PageFormatOperation {

    ByteString dataPageType;

    @Override
    public void init() {
    }

    public final String getDataPageType() {
        return dataPageType.toString();
    }

    public final void setDataPageType(String dataPageType) {
        this.dataPageType = new ByteString(dataPageType);
    }

    @Override
    public int getStoredLength() {
        return super.getStoredLength() +
            dataPageType.getStoredLength();
    }

    @Override
    public void retrieve(ByteBuffer bb) {
        super.retrieve(bb);
        dataPageType = new ByteString();
        dataPageType.retrieve(bb);
    }

    @Override
    public void store(ByteBuffer bb) {
        super.store(bb);
        dataPageType.store(bb);
    }
}
\end{verbatim}

As astute reader will notice that the Page Format operation extends
the BaseLoggable class and implements both Redoable and
PageFormatOperation interfaces. The BaseLoggable class and the
PageFormatOperation interface are described further below.

\subsection{BaseLoggable abstract class}
The Transaction Manager provides the BaseLoggable abstract class
which implements the Loggable interface. Rather than attempting to
implement the Loggable interface from scratch, it is highly
recommended that clients sub-class the BaseLoggable class and extend
it to add functionality. The reason for making Loggable an interface
and not an abstract class like BaseLoggable is that it allows the
client to implement its own class hierarchy independently from the
Loggable hierarchy.

\subsection{PageFormatOperation}
Operations that format new pages are particularly important because
the Transaction Manager must invoke the Buffer Manager FIX AS NEW
interface to fix pages affected by them. If the normal fix interface
is called, an exception will be thrown because the page may not
exist on disk or may be garbage. To allow the Transaction Manager to
spot page format operations, all log records that perform such
actions should implement the PageFormatOperation interface. This is
a marker interface only.

Usually, PageFormatOperations are redo-only.

In SimpleDBM, the page format operations are handled when a
container is created or expanded.

\subsection{MultiPageRedo}
Normally a Redoable log record represents changes to a single page.
Sometimes, however, it may be necessary for a single log record to
contain changes made to multiple pages. In such cases, the Log
record should implement the MultiPageRedo interface.

Note that clients need to follow the following procedure when
creating MultiPageRedo log records.

\begin{itemize}
\item Fix all the affected pages.
\item Generate the MultiPageRedo log record.
\item Apply changes to the affected pages.
\item Set the pageLsn of all affected pages to the LSN of the log record.
\item Unfix all affected pages.
\end{itemize}
\subsection{Undoable}
Logs records that need to be undoable should implement the Undoable
interface. The Undoable interface extends the Redoable interface,
thus, undoable log records are by definition redoable as well.

An Undoable log record should contain data that can be used to
``redo'' the changes, as well as to ``undo'' the changes. Typically,
this means that both old and new values must be stored. For example,
if the log is to represent changing a field value from A to B, then
its old value will be A, and new value will be B.

At system restart, Undoable records are redone. This means that the
redo portion of such log records are applied. In the example given
above, this would cause the field value to be set to B.

When the Transaction Manager needs to undo the changes represented
by an Undoable record, it will ask the client to perform one of
following depending upon the type of Undoable record:

\begin{itemize}
\item If the Undoable record is an instance of SinglePageLogicalUndo, then the Transaction Manager assumes that the undo operation must be performed against some page other than the one originally affected. However, the undo is known to affect only one page. In this situation the Transaction Manager requests the client to identify the page to which undo should be applied, and then coordinates the generation of undo as normal.
\item If the Undoable record is an instance of LogicalUndo, then the Transaction Manager assumes that the undo operation is not an exact inverse of the redo operation and may require updates to one or more pages. It also assumes that the client may generate additional log records. For such log records, the client is given full control over how the undo is to be performed.
\item If neither of above are true, then the Transaction Manager assumes that the Undo operation is ``physical'', i.e., it is to be applied to the same page that was affected by the original change. In this case, it requests the client to generate the undo information (Compensation) which is then applied as a redo operation.
\end{itemize}
Following sections describe above in reverse order.

\subsection{Physical Undos}
The simplest case is that of a Physical Undo, where the undo
operation affects the same page that was originally modified during
forward change (i.e., redo). In this case, the Transaction Manager
asks the client to generate a Compensation record for redoing the
undo operation. This is then applied to the affected page using the
redo interface provided by the client. Following code shows how the
Transaction Manager interacts with the client:

\begin{verbatim}
    Compensation clr = module.generateCompensation(undoable);
    ....
    module.redo(page, clr);
\end{verbatim}

Thus, for this type of log record, the client must implement the
generateCompensation(Undoable) and redo(Page, Redoable) operations.

\subsection{SinglePageLogicalUndos}
SinglePageLogicalUndos are slightly more complex than Physical
undos. The undo operation is guaranteed to affect one page only, but
it may not be the page originally affected. To handle this scenario,
the Transaction Manager first asks the client to identify the page
where the undo is to be applied. Once this has been done, the
process is identical to that of Physical undos. Following code
extract shows how the TM interacts with the client:

\begin{verbatim}
    BufferAccessBlock bab = module.findAndFixPageForUndo(undoable);
    ...
    Compensation clr = module.generateCompensation(undoable);
    ...
    module.redo(bab.getPage(), clr);
    ...
    bab.unfix();
\end{verbatim}

What above shows is that the client is responsible for identifying
and fixing the appropriate page -- the page is unfixed by
Transaction Manager once the change has been applied.

\subsection{LogicalUndos}
From the client's perspective the most complex type of undo is where
the undo operation may impact several pages, and may result in
additional log records being generated.

For such records, the Transaction Manager simply invokes the
client's undo interface as follows:

\begin{verbatim}
    module.undo(trx, undoable)
\end{verbatim}

It is the client's responsibility to generate appropriate log
records and make changes to database pages.

\subsection{Comments about implementing undo operations}
From the discussion above, it should be clear that Physical undos
are the easiest to implement. They are also the most efficient.
However, in some cases, notably in Index operations, physical undos
may not be optimum. This is because in a BTree Index, a key can move from
one page to another as a result of page splits or page merges.

In some BTree implementations, such as in Apache Derby, the undo
operations are limited to a single page. This is achieved through
the use of ``logical key deletes''.

Where keys are physically deleted, undo of key deletes may cause
page splits. Such undo operations may impact more than one page. The
SimpleDBM BTree implementation is an example of this type of
operation.

\subsection{Compensation records}
Undo operations are represented using Compensation log records. The
benefits of using Compensation log records are explained in detail
by Mohan in the ARIES paper. As Mohan explains in his paper, a
Compensation record is redo-only -- it is never undone. A unique
property of ARIES algorithm is that Compensation log records are
linked back to the predecessor of the log record that is being
undone. This backward chaining allows ARIES to skip processing of
undo operations that are already applied.

While Compensation log records are mostly used to represent undo
operations, sometimes, they can be effectively used to represent
redo operations as well. The system can make use of the backward
chaining to allow certain log records to be skipped in the event of
an undo. This feature is the basis for the Nested Top Action concept
in ARIES. It is also exploited by the SimpleDBM BTree implementation
to reduce the amount of logging required for structure modification
operations. For further details, please refer to the paper entitled
-- \textit{Space Management issues in B-Link trees}.

\subsection{NonTransactionRelatedOperations}
A NonTransactionRelatedOperation is one that should be redone
without reference to a database page. Note that such operations are
discarded after a Checkpoint, i.e, only those records will be redone
that are encountered after the last Checkpoint. Is is therefore
important to ensure that the effect of these log records are also
saved in Checkpoint operations.

In SimpleDBM, the only use of this operation at present is to log
opening of containers. After a container is created, a
NonTransactionRelatedOperation is logged to ensure that the
container will be reopened at system restart. A Checkpoint operation
in SimpleDBM includes a list of all open containers, hence, any past
open container log records become redundant after the Checkpoint.

\subsection{PostCommitActions}
PostCommitActions are used to defer certain actions until it is
known for sure that the Transaction is definitely committing. In
SimpleDBM, dropping a container is handled this way. When a request
is made by a client to drop a container, a PostCommitAction is
scheduled to occur once the transaction commits.

The Transaction Manager tracks the status of PostCommitActions and
ensures that once a transaction has committed, its PostCommitActions
are executed even if there is a system crash. This is achieved by
logging such actions as part of the transaction's Prepare log
record. Note that a PostCommitAction may be executed more than once
by the TransactionManager, hence it should be coded in such a way
that there is no adverse impact if the operation is repeated. For
example, if the action is to delete a container, it would be
erroneous for the PostCommitAction to complain if the container is
already deleted.

\subsection{ContainerDeleteOperations}
Since an ARIES style Transaction Manager operates at the level of
disk pages, it is necessary to know when a container has been
deleted so that all pages related to the container can be marked
invalid. Also, the container needs to be closed to prevent further
changes to it. The Transaction Manager uses the
ContainerDeleteOperation interface as a marker interface to identify
log records that are going to cause containers to be dropped.

\chapter{Space Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
 \verb|org.simpledbm.rss.sm| & \verb|org.simpledbm.rss.sm.impl| \\
\hline
\end{tabular}

\section{Introduction}
The Space Manager module is responsible for managing free space
information within a Storage Container. Using free space
information, the Space Manager module can find pages that meet space
requirements of clients. The Space Manager module also handles
creation of new containers and expansion/deletion of existing
containers.

\section{Comparison with Storage Manager module}
We have previously encountered the Storage Manager module which
provides facilities for creating and dropping specific containers.
However, these operations are low-level, and not transactional.
Containers created by the Storage Manager module are raw, and do not
have any structure.

The Space Manager module implements a higher level interface. It
differs from the Storage Manager module in following ways:

\begin{itemize}
\item Its operations are transactional.
\item Containers have a predefined structure and support fixed-size pages.
\item The Space Manager module implements special pages within the container where information about other pages is maintained. This information can be used to quickly locate a page with specified amount of storage.
\end{itemize}

\section{Obtaining an instance of SpaceMgr}

The default implementation of the SpaceMgr module is
\verb|org.simpledbm.rss.sm.impl.SpaceMgrImpl|.
As can be seen in the example below, the SpaceMgr module depends
upon a number of other modules.

\begin{verbatim}
SpaceMgr spacemgr = new SpaceMgrImpl(objectFactory, pageFactory,
        logmgr, bufmgr, storageManager, storageFactory,
        loggableFactory, trxmgr, moduleRegistry);
\end{verbatim}

\section{Creating a Container}
Following sample code demonstrates how to create a Container. Note
that for correct operation, the container ID allocated to the new
container should be locked exclusively prior to creating the
container. This will prevent other transactions from manipulating
the same container.

\begin{verbatim}
SpaceMgr spacemgr = new SpaceMgrImpl(...);
Transaction trx = trxmgr.begin();
boolean okay = false;
try {
   // Create a new Container named testctr.dat and assign it a container
   // ID of 1. This container will use RawPages as its data page.

   int containerId = 1;
   int spaceBits = 1;
   int extentSize = 64;
   spacemgr.createContainer(trx, "testctr.dat", containerId,
      spaceBits, extentSize, pageFactory.getRawPageType());

   okay = true;
}
finally {
   if (okay) {
      trx.commit();
   }
   else {
      trx.abort();
   }
}
\end{verbatim}

Note that the container create operation is transactional.

\section{Extending a Container}

When a container is initially created, it is allocated an extent of
specified size. The extent is the minimum allocation unit for a
container; a container is always expanded in extents.

\begin{verbatim}
Transaction trx = trxmgr.begin();
spacemgr.extendContainer(trx, 1);
trx.commit();
\end{verbatim}

\section{Deleting a container}

Note that prior to deleting a container, you must acquire an
Exclusive lock on the container ID. This will prevent other transactions
from accessing the same container.

Deleting a container is as simple an operation as extending it:

\begin{verbatim}
Transaction trx = trxmgr.begin();
spacemgr.dropContainer(trx, 1);
trx.commit();
\end{verbatim}

An important point to note about the container delete operation
is that the physical removal of the container is deferred until
the transaction commits. This is done to allow the delete operation
to be rolled back in case the transaction aborts.

A limitation in the current implementation is that the container
is not physically removed. This will be fixed in a future revision
of the module.

\section{Searching for free space}

At the time of creating a container, you can specify the number
of bits that should be used to track space information for each
individual page. At present, you can either use a single
bit or two bits. If one bit is used, the possible values are
0 and 1, if two bits are used, then the possible values are 0,
1,2 and 3. The SpaceMgr module initializes the space bits with a
value of 0, hence this value always means unused or unallocated
space. The interpretation of other values is upto the client;
SpaceMgr merely provides the mechanism to maintain
this data.

As an example, in the BTree module, containers are created with
a single bit for each page. The value 0 is used to identify
unallocated pages, 1 is used for allocated pages.

In order to search for free space, you first need to obtain
a SpaceCursor. The SpaceCursor mechanism allows you to perform
following actions:

\begin{enumerate}
\item Search for page with specified space usage, and fix associated space map page exclusively.
\item Update the space map information for a page, and log this operation.
\item Fix a specific space map page.
\item Unfix the currently fixed space map page.
\end{enumerate}

When you search for free space, you need to provide an implementation
of \verb|SpaceChecker|; this will be invoked by SpaceMgr module to
check whether a page meets the space requirements of the client.

Here is an example of a search that attempts to locate pages that
are unallocated:

\begin{verbatim}
int pageNumber = spaceCursor.
      findAndFixSpaceMapPageExclusively(new SpaceChecker() {
   public boolean hasSpace(int value) {
      return value == 0;
   }
});
\end{verbatim}

If the SpaceCursor cannot locate a suitable page, it returns -1. Otherwise it
returns the page that satisfied the space request.

An important point to note is that just because space map information
indicates that the page has free space, does not always mean that the page
will be able to satisfy the request. Some modules, such as the TupleMgr
module, may mark pages as free even though they are still occupied.
Please refer to the TupleMgr documentation to understand why this is
so. In general, it is upto the client module to ensure that the space
map information is accurate and up-to-date.

Usually, if the space map search returns -1, the container needs to be
extended and then the search retried.

\section{Updating space information}

A successful search will result in the space map page being erxclusively
latched. Hence, after the search, the client must unfix the page. Failure
to do so will cause pages to remain fixed and exhaust the Buffer Pool.
The SpaceCursor interface provides an interface for unfixing the
currently fixed space map page.

\begin{verbatim}
Transaction trx = trxmgr.begin();
spaceCursor.updateAndLogRedoOnly(trx, pageNumber, 1);
spaceCursor.unfixCurrentSpaceMapPage();
trx.commit();
\end{verbatim}

Above example also shows how to update the space map page information
and also log it to the Write Ahead Log.

There will be times when the client wishes to update the space
information for a specific page. In this situation it is the client's
responsibility to know which space map page contains the associated
data.

The SpaceCursor interface supports accessing a specific space
map page, provided it is known which page is desired:

\begin{verbatim}
Transaction trx = trxmgr.begin();
SpaceCursor spcursor = spaceMgr.getSpaceCursor(containerId);
spcursor.fixSpaceMapPageExclusively(spaceMapPageNumber,
   pageNumber);
try {
   pcursor.updateAndLogRedoOnly(trx, pageNumber, spacebits);
} finally {
   spcursor.unfixCurrentSpaceMapPage();
}
trx.commit();
\end{verbatim}

\chapter{Slotted Page Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
\verb|org.simpledbm.rss.sp| & \verb|org.simpledbm.rss.sp.impl| \\
\hline
\end{tabular}

\section{Introduction}

SimpleDBM, like most other databases, stores records in fixed size
pages. The Slotted Page Manager module provides an enhancement to
the Raw Page by allowing records to be inserted, updated and deleted
within the page. By providing a common infrastructure, client
modules such as the B-Tree Manager or the Tuple Manager can
concentrate on higher level functions.

\section{Structure of Slotted Page}

From the client perspective, the structure of the Slotted Page is
not relevant in its details. What matters is the interface. A key
requirement is to be able to access records quickly within the page,
using a numeric identifier called Slot Number.

Each record in the page is assigned a Slot Number. Slot Numbers
start from 0, ie, the first record in the page can be accessed via
Slot Number 0.

In addition to storing the record data, each Slot is also capable of
storing a set of flags in a Short integer. The interpretation of
these flags is up to the client module.

Records may be inserted at a specific Slot position, updated and
deleted. Deleted records leave the Slot unoccupied, but do not shift
records. A purge interface is available which completely removes the
record specified and also shifts to the left all records to the right of
the purged record.

\section{Obtaining instances of Slotted Page}

The actual implementation of the Slotted Page is not visible to the
outside world. The Slotted Page Manager module ``registers'' the
implementation of SlottedPage to the Object Registry. This enables
client modules to obtain new instances of SlottedPage without having
to know how this is implemented. Following snippet of code
illustrates this:

\begin{verbatim}
SlottedPageMgr spmgr = new SlottedPageMgrImpl(objectFactory);
SlottedPage page = (SlottedPage)
   pageFactory.getInstance(spmgr.getPageType(), new PageId());
\end{verbatim}

Note that the PageFactory is able to instantiate the appropriate
Page type using the typecode (\verb|spmgr.getPageType()|) assigned
to the implementation by the SlottedPageManager module.

In most cases, clients do not actually invoke the PageFactory as
shown above. Instead it is more common to specify the page type when
a container is first created; this ensures that the Buffer Manager
module can instantiate the correct page type automatically. Here is
an example of how to do this:

\begin{verbatim}
// Create the container and specify SlottedPage as the page
// type.
spaceMgr.createContainer(trx, name, containerId, spacebits,
   extentSize, spmgr.getPageType());

// Fix page 5
BufferAccessBlock bab = 
   bufmgr.fixExclusive(new PageId(containerId, 5), false, -1, 0);

// Get access to the page.
SlottedPage page = (SlottedPage) bab.getPage();
\end{verbatim}

In the example above, the Space Manager module formats all data 
pages in the specified container as SlottedPage. This ensures that when the client
module accesses the page via the Buffer Manager, the correct page
type is automatically instantiated.

\section{Inserting or updating records}

The SlottedPage interface supports two insert modes. In the
replace mode, the new record will replace any existing record at 
the same Slot. If replace mode is false, the new record will cause
existing records to be shifted to the right to make space for the
new record. 

\begin{verbatim}
boolean replaceMode = false;
// Insert item1 at Slot 0
page.insertAt(0, item1, replaceMode);
// Insert item0 at Slot 0
page.insertAt(0, item0, replaceMode);
// Now item1 is at Slot 1
\end{verbatim}

When invoking \verb|SlottedPage.insertAt()|, the SlotNumber must be
between 0 and \verb|SlottedPage.getNumberOfSlots()|. 

\section{Deleting records}

As mentioned before, there are two types of delete.
The first type removes the record but does not disturb the
Slot Numbers. Example:

\begin{verbatim}
// Insert at slot 0
page.insertAt(0, item0, true);
// Insert at slot 1
page.insertAt(1, item1, true);
// Delete slot 0
page.delete(0)
// Slot 1 still holds item1
\end{verbatim}

The second mode is called purge, and in this mode,
records to the right of the deleted Slot are moved
left to fill up the hole. Example:

\begin{verbatim}
// Insert at slot 0
page.insertAt(0, item0, true);
// Insert at slot 1
page.insertAt(1, item1, true);
// Delete slot 0
page.purge(0)
// Slot 0 now holds item1
\end{verbatim}

\section{Accessing records}

The \verb|SlottedPage.getNumberOfSlots()| method returns the number
of slots in the page. To access a slot, you invoke \verb|SlottedPage.get()|; 
you must supply the correct \verb|Storable| object 
type as the second parameter. 

\begin{verbatim}
// Get the record at Slot 1 as a StringItem.
page.get(1, new StringItem()); 
\end{verbatim}

\section{Miscellaneous operations}

It is possible to assign to each Slot a set of flags. 
Upto 16 bits can be accomodated. 

\begin{verbatim}
// Get the flags for Slot 0
int flags = page.getFlags(0);
// Update the flags for Slot 0
page.setFlags(0, (short)(flags | 1)); 
\end{verbatim}

The total number of Slots in the page is returned by
the mthod \verb|getNumberOfSlots()|. To test whether a particular Slot is deleted, you can use
the method \verb|isSlotDeleted()|. 
There are a few methods that provide space usage data.

\chapter{Index Manager}
\begin{tabular}{|c|c|}
\hline
           Interface           &           Implementation           \\
\hline
\verb|org.simpledbm.rss.bt| & \verb|org.simpledbm.rss.bt.impl| \\
\hline
\end{tabular}

\section{Overview}

The Index Manager module is responsible for implementing search structures
such as BTrees. Indexes are used to enforce primary key constraint and unique
constraints in tables, as well as for ensuring speedy retrieval of data.

\section{Index Keys}

Index Keys are the searchable attributes stored in the Index. This module
specifies Index Keys in a fairly general way:

\begin{verbatim}
public interface IndexKey extends Storable, Comparable<IndexKey> {
	
  /**
   * Used mainly for building test cases; this method should
   * parse the input string and initialize itself. The contents 
   * of the string is expected to match the toString() output.
   */
  void parseString(String string);
}
\end{verbatim}

The requirements for an IndexKey are fairly simple. The key must be
Storable and Comparable. Note that this interface does not say anything
about the internal structure of the key; in particular it does not 
specify whether the key contains multiple attributes. This is deliberate,
as it makes the Index Manager module more generic.

Depending upon the implementation, there may be restricions on the
size of the key. For instance, in a BTree implementation, the key
should not exceed 1/8th of the page size, ie, 1KB. 

\section{Index Key Factories}

An Index Key Factory is used to create new keys. 

\begin{verbatim}
public interface IndexKeyFactory {

  /**
   * Generates a new (empty) key for the specified
   * Container. The Container ID is meant to be used as key
   * for locating information specific to a container; for instance,
   * the attributes of an Index.
   */
  IndexKey newIndexKey(int containerId);

  /**
   * Generates a key that represents Infinity - it must be greater than
   * all possible keys in the domain. 
   */
  IndexKey maxIndexKey(int containerId);
}
\end{verbatim}

An implementation is free to use any method it likes for 
identifying keys that represent ``Infinity'', as long as it ensures
that this key will always be greater than any other key in
the domain.

Given below is an example of an IndexKey and IndexKeyFactory 
implementation that supports keys in the range of 1-100. Note 
this in this implementation, the value of -1 is used to
represent ``Infinity''.

\begin{verbatim}
public class IntKey implements IndexKey {
  static final int INFINITY = -1;
 	static final int NULL = 0;
 	int i;
 	public IntKey() {
    i = NULL;
 	}
 	public IntKey(int i) {
    setInt(i);
 	}
  public int compareTo(IndexKey o) {
    if (o instanceof IntKey) {
      if (i == INFINITY) {
        return 1;
      }
      return i - ((IntKey)o).i;
    }
    return -1;
  }
  public void setInt(int i) {
    if (i < INFINITY || i > 100) {
      throw new IllegalArgumentException();
    }
    this.i = i;
  }
  @Override
  public String toString() {
    return Integer.toString(i);
  }
  public void parseString(String string) {
    setInt(Integer.parseInt(string));
  }
  public int getStoredLength() {
    return Integer.SIZE/Byte.SIZE;
  }
  public void retrieve(ByteBuffer bb) {
    i = bb.getInt();
  }
  public void store(ByteBuffer bb) {
    bb.putInt(i);
  }
}

public class IntKeyFactory implements IndexKeyFactory {
  public IndexKey newIndexKey(int containerId) {
    return new IntKey();
  }
  public IndexKey maxIndexKey(int containerId) {
    return new IntKey(IntKey.INFINITY);
  }
}
\end{verbatim}


\end{document}
